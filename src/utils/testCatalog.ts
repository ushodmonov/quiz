import type { Question } from '../types'

export interface TestCatalogItem {
  id: string  // Auto-generated if not provided in JSON
  name: string
  path?: string  // Optional, file path relative to assets folder
  description?: string
  semester?: string | number  // Qaysi semestr (e.g., "1", "2", or 1, 2)
  years?: string  // Qaysi yillar (e.g., "2025-2026")
  subject?: string  // Qaysi fandanligi (e.g., "Tibbiy kimyo", "Odam anatomiya")
  courses?: string | number | (string | number)[]  // Qaysi kurslar uchun (e.g., 1, "1", [1, 2], "1-kurs")
  institute?: string  // Qaysi institut uchun (e.g., "TTDU", "Toshkent Tibbiyot Universiteti")
  sub_catalogs?: TestCatalogItem[]  // Support both spellings
  sub_catologs?: TestCatalogItem[]  // Typo version for backward compatibility
}

/**
 * Generate ID from test item fields
 * Priority: path > subject > name
 */
function generateTestId(test: Omit<TestCatalogItem, 'id'>, parentId?: string): string {
  // If path exists, use it as base (remove extension)
  if (test.path) {
    const baseName = test.path.replace(/\.(txt|docx)$/i, '')
    const id = baseName.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '')
    return parentId ? `${parentId}-${id}` : id
  }
  
  // If subject exists, use it
  if (test.subject) {
    const id = test.subject.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '')
    return parentId ? `${parentId}-${id}` : id
  }
  
  // Fallback to name
  const id = test.name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '')
  return parentId ? `${parentId}-${id}` : id
}

/**
 * Add auto-generated IDs to test items recursively
 */
function addAutoGeneratedIds(tests: Partial<TestCatalogItem>[], parentId?: string): TestCatalogItem[] {
  return tests.map((test) => {
    const id = test.id || generateTestId(test as Omit<TestCatalogItem, 'id'>, parentId)
    const subCatalogs = test.sub_catalogs || test.sub_catologs
    
    const processedTest: TestCatalogItem = {
      ...test,
      id
    } as TestCatalogItem
    
    if (subCatalogs && subCatalogs.length > 0) {
      processedTest.sub_catalogs = addAutoGeneratedIds(subCatalogs, id)
      processedTest.sub_catologs = processedTest.sub_catalogs
    }
    
    return processedTest
  })
}

export interface TestCatalog {
  tests: TestCatalogItem[]
}

/**
 * Get base URL for assets (handles GitHub Pages subdirectory)
 */
function getBaseUrl(): string {
  // Vite provides BASE_URL which includes the base path
  // For GitHub Pages: if base is '/quiz/', BASE_URL will be '/quiz/'
  // For local dev: BASE_URL will be '/'
  const baseUrl = import.meta.env.BASE_URL || '/'
  // Ensure baseUrl ends with '/' for proper path joining
  return baseUrl.endsWith('/') ? baseUrl : `${baseUrl}/`
}

/**
 * Load test catalog from JSON file
 */
export async function loadTestCatalog(): Promise<TestCatalog> {
  try {
    const baseUrl = getBaseUrl()
    const response = await fetch(`${baseUrl}assets/test-catalog.json`)
    if (!response.ok) {
      return { tests: [] }
    }
    const data = await response.json()
    // Add auto-generated IDs if not present
    const testsWithIds = addAutoGeneratedIds(data.tests || [])
    return { tests: testsWithIds }
  } catch (error) {
    console.error('Failed to load test catalog:', error)
    return { tests: [] }
  }
}

/**
 * Load questions from a test file in assets
 */
export async function loadTestQuestions(filePath: string): Promise<Question[]> {
  try {
    const baseUrl = getBaseUrl()
    // Encode the filePath to handle special characters and paths
    // Split by '/' to encode each segment separately, then join back
    const encodedPath = filePath
      .split('/')
      .map(segment => encodeURIComponent(segment))
      .join('/')
    const response = await fetch(`${baseUrl}assets/${encodedPath}`)
    if (!response.ok) {
      throw new Error(`Failed to load file: ${filePath}`)
    }
    
    // Check file extension
    if (filePath.toLowerCase().endsWith('.txt')) {
      const text = await response.text()
      const { parseTxtFile } = await import('./fileParser')
      return parseTxtFile(text)
    } else if (filePath.toLowerCase().endsWith('.docx')) {
      const arrayBuffer = await response.arrayBuffer()
      // Use parseDocxFileFromBuffer to properly parse DOCX with table support
      const { parseDocxFileFromBuffer } = await import('./fileParser')
      return parseDocxFileFromBuffer(arrayBuffer)
    } else {
      throw new Error(`Unsupported file format: ${filePath}`)
    }
  } catch (error) {
    console.error('Failed to load test questions:', error)
    throw error
  }
}

/**
 * Generate test catalog from DOCX files in assets
 * This function should be run once to create the catalog
 */
export async function generateTestCatalog(): Promise<TestCatalogItem[]> {
  // This would be run as a build script or admin function
  // For now, return empty array - catalog should be manually created
  return []
}
